"""
ФУНКЦИИ

Как объявить и вызвать функцию

Задание 1

Возможно, ты знаешь про пирамиду тестов.
Она показывает, каких тестов на проекте должно быть больше, а каких меньше.
У пирамиды три уровня:
На вершине — тесты пользовательского интерфейса, или GUI-тесты, их меньше всего.
В середине — сервисные тесты, или интеграционные тесты.
Снизу — юнит-тесты, их больше всего.
Создай функцию testing_pyramid(). Она будет выводить эту пирамиду.
Выведи с помощью print() три строчки:
«GUI-тесты»;
«сервисные тесты»;
«юнит-тесты».
Не забудь выполнить функцию.

"""


# создай функцию testing_pyramid() и напечатай пирамиду тестов
def testing_pyramid():
    print('GUI-тесты')
    print('сервисные тесты')
    print('юнит-тесты')


testing_pyramid()

"""

Задание 2

Команды, которые работают по Agile, планируют время на задачи в текущем спринте. 
Время измеряют в особой единице — story points (SP).
На каждую задачу выделяется сколько-то SP.
Например, на первую три, на вторую — пять и так далее.
Твоя задача — реализовать функцию check_story_points_sum().
Она определяет по сумме всех SP, укладывается команда в сроки или нет:
Если сумма всех SP меньше или равно 80, выводим «Укладываемся в спринт».
Если сумма больше, выводим «Задачи не влезают. Нужно что-то выкинуть».
Чтобы подсчитать сумму всех элементов списка, используй функцию sum(). Получится так: sum(tasks).

"""

# нулевой спринт, без задач
tasks = []


def check_story_points_sum():
    if sum(tasks) <= 80:
        print('Укладываемся в спринт')
    else:
        print('Задачи не влезают. Нужно что-то выкинуть')


# первый спринт
tasks = [3, 3, 13, 8, 13, 2, 5, 5, 1, 13, 8, 2, 5]

check_story_points_sum()

# второй спринт
tasks = [5, 3, 13, 5, 13, 2, 5, 5, 2, 13, 8, 1, 5]

check_story_points_sum()

# третий спринт
tasks = [13, 13, 13, 8, 5, 2, 5, 2, 1, 5, 8, 2, 2]

check_story_points_sum()

"""
Аргументы и параметры

Задание 1

Вернемся к story points из предыдущего урока. Напиши функцию.
На вход она будет принимать число SP для одной задачи. 
В теле функции будет условие: 
Если задача занимает меньше 8SP, добавляем её в список current_sprint.
Если нет, откладываем на следущий раз — добавляем в список not_in_sprint.
В конце выведи сумму SP в спринте и сумму тех SP, которые не уместились в спринт.
Используй sum: например, sum(current_sprint).

"""

current_sprint = []
not_in_sprint = []


def add_task_to_sprint(story_points):
    if story_points < 8:
        current_sprint.append(story_points)
    else:
        not_in_sprint.append(story_points)

    # тут напиши код, который добавляет SP в нужный спринт


add_task_to_sprint(2)

add_task_to_sprint(5)

add_task_to_sprint(5)

add_task_to_sprint(13)

add_task_to_sprint(8)

add_task_to_sprint(1)

add_task_to_sprint(2)

# выведи сумму SP в спринте и сумму тех SP, которые не уместились в спринт
print(sum(current_sprint))

"""

Задание 2

На сайтах есть разные способы аутентификации пользователей: по логину и паролю, по смс и так далее.
Твоя задача — написать функцию, которая проверит, достаточно ли переданных данных для авторизации на сайте.
На вход подается один параметр — user.
Он соответствует списку, состоящему из трех элементов: логина, пароля и токена.
Но не у всех пользователей эти параметры заполнены.
Функция is_authorized_user(user):
Выводит на экран «OK» латинскими буквами, если пользователь сможет авторизоваться по одному из способов:
по логину и паролю или по токену.
Если не сможет хотя бы по одному из них, ничего не выводит.
Элементы в списках передаются строго по порядку: логин, пароль, токен.

"""
def is_authorized_user(user):
    if user[0] and user[1] or user[2]:
        print('OK')
	# твой код


user_1 = ['login', 'password', '']

is_authorized_user(user_1)

user_2 = ['', '', 'token']

is_authorized_user(user_2)

user_3 = ['login', '', '']

is_authorized_user(user_3)

user_4 = ['', '', '']

is_authorized_user(user_4)

"""
Возврат значений из функции

Задание 1

В любом автотесте нужно сравнивать эталонное состояние с полученным. Попробуй сделать это через обычную функцию. 
Твоя задача  — доработать функцию:

Если состояния condition_a и condition_b совпадают, она возвращает True.
Если состояния не совпадают — False.

"""
def condition_check(condition_a, condition_b):
    if condition_a == condition_b:
        return True
    else:
        return False

# вызовы функций не меняй
print(condition_check('a', 'b'))   # False

print(condition_check(1, '1'))     # False

print(condition_check(['Кнопка 1', 'Поле 2'], ['Кнопка 1', 'Поле 1'])) # False

print(condition_check(['Кнопка 1', 'Поле 1'], ['Кнопка 1', 'Поле 1'])) # True

"""
Задание 2

Палиндром — слово или фраза, которые одинаково читаются слева направо и справа налево.
Например, фраза «искать такси» — это палиндром. 
Доработай функцию, чтобы она определяла, палиндром перед ней или нет.
Либо True, либо False.
Функция работает так:
Пробелы не должны учитываться, поэтому в теле функции убираем их через replace(' ', '').
Чтобы получить перевернутую строку, используем string[::-1].
Он работает одинаково как для списков, так и для строк.

"""

def is_palindrome(string):
    # убираем пробелы
    string_no_space = string.replace(' ', '')
    # получаем строку в обратном порядке
    reversed_string = string_no_space[::-1]
    # допиши код, возвращающий True или False
    if string_no_space == reversed_string:
        return True
    else:
        return False

print(is_palindrome('молебен о коне белом'))  # True

print(is_palindrome('колобок'))  # False

print(is_palindrome('121'))  # True

"""
Значение по умолчанию и разные виды аргументов

Задание 1

Вернёмся к способам аутентификации на сайте.
Теперь на вход функции будет передаваться не один параметр, а целых три: login, password, token. 
Твоя задача — доработать саму функцию и её вызовы так, чтобы не возникло ошибок.
Списки с данными пользователей не обязательно содержат все три параметра. 
Если понадобится значение по умолчанию, используй пустую строку.

"""
def is_authorized_user(login='', password='', token=''):
	# тело функции менять не нужно
	if login and password or token:
			print('OK')

user_1 = ['', '', '']

# тут просто 3 параметра - 3 значения в списке
is_authorized_user(user_1[0], user_1[1], user_1[2])

user_2 = ['login', 'password']

# у user_2 теперь всего 2 параметра
is_authorized_user(login=user_2[0], password=user_2[1])

user_3 = ['token']

# у user_3 только токен
is_authorized_user(token=user_3[0])

user_4 = ['login', '']

# у user_4 токена нет, но и пароль отсутсвует
is_authorized_user(login=user_4[0])

"""

Библиотеки

Задание
Для автотестов нужны разные фейковые данные. Например, номера телефонов или ФИО пользователей.
Есть специальные библиотеки, но зачастую с этим справится и обычный рандомайзер. 
Стандартный номер мобильного телефона состоит из:
Код страны — например, +7.
Код оператора — например, 910 (диапазон значений от 100 до 999).
Оставшиеся семь цифр — например, 123-45-67 или без дефисов 1234567.
Диапазон значений от 1000000 до 9999999.
Создай свой генератор для мобильного номера.
Подключи библиотеку random. Используй функцию randint() из этой библиотеки: сгенерируй фейковый номер. 
Функция randint(a, b) возвращает случайное числовое значение из переданного диапазона.
Например, вызвав randint(100, 999) , получим число из диапазона 100 ... 999, включая границы.

"""

# Подключи библиотеку random и дай ей краткое имя
import random as r

country_code = '+7'  # код страны пусть будет всегда +7

# используй randint, чтобы сгенерировать трехзначный код оператора
operator_code = r.randint(100, 999)

# используй randint, чтобы сгенерировать оставшиеся 7 цифр (без дефисов)
last_digits = r.randint(1000000, 9999999)

fake_number = country_code + str(operator_code) + str(last_digits)

print(fake_number)

"""

Вызов функции из функции

Задание 1

Создай функцию, которая определяет, есть ли у пользователя доступ к странице.
Функция has_permission принимает на вход два параметра — страницу и пользователя.
Она вызывает внутри себя другую функцию is_admin. Эта функция определяет, админ ли текущий пользователь или нет.
Функция has_permission возвращает True, если у пользователя есть доступ на страницу.
И False, если нет доступа.
Правила доступов:
Всем пользователям доступны страницы: 'Рестораны', 'Заказы' и 'Избранное'.
Пользователю 'admin' также доступна страница 'Управление'.

"""


# функция определяет, админ ли текущий пользователь
def is_admin(user):
    return user == 'admin'

# функция определяет, есть ли доступ у текущего пользователя на страницу
def has_permission(page, user):
    if page == 'Управление':
        return is_admin(user)
    return True

print(has_permission('Рестораны', 'user_a'))

print(has_permission('Избранное', 'admin'))

print(has_permission('Управление', 'admin'))

print(has_permission('Управление', 'user_b'))

"""
Задание 2

Ты уже умеешь генерировать рандомный фейковый телефон, который можно использовать в автотестах.
Теперь попробуй сгенерировать целый набор таких фейковых данных: название компании, телефон и ИНН.
Название. Формируется по принципу: если это организация org=True,  добавляется в начале ОАО.
А если нет, то ИП. Например:
'ОАО Крутые автотесты' — ОАО в зависимости от параметра org,
а Крутые автотесты мы передаем как значение параметра name.
'ИП Напродов Баг Фиксович' — ИП в зависимости от параметра org,
а Напродов Баг Фиксович — значение параметра name.
Для примера возьми «Дом у дороги» (ОАО) и «Шрут Дуайт Курт» (ИП).
Телефон. Начинается на +7, а дальше 10 рандомных цифр без пробелов:
диапазон от 1000000000 до 9999999999. Например, '+71234567899'.
Тип — строка.
ИНН. Не будем вдаваться в правила построения: просто сгенерируем его в зависимости от типа.
Для организации — 9 цифр, для ИП 12 цифр. Тип — число. 
Используй библиотеку random. Она уже импортирована. 
Тебе понадобится метод randint.
Он генерирует число из диапазона от а до b.
Любое число из этого диапазона не может быть записано с несколькими нулями вначале:
они просто обрежутся при переводе в число. То есть число 00034 будет просто 34 .
Учти это при указании левой границы диапазонов.

"""

import random

def get_random_name(name, org=True):
    # сгенерируй Название в зависимости от параметра org
    if org == True:
        return 'ОАО ' + name
    else:
        return 'ИП ' + name

def get_random_inn(org=True):
    # сгенерируй ИНН в зависимости от параметра org
    if org == True:
        return random.randint(100000000, 999999999)
    else:
        return random.randint(100000000000, 999999999999)


def get_random_phone():
    # сгенерируй телефон
    a = random.randint(1000000000, 9999999999)
    return '+7' + str(a)


def fake_builder(name, org=True):
    return {
        'Название': get_random_name(name, org),  # используй функцию для генерации имени
        'ИНН': get_random_inn(org),  # используй функцию для генерации ИНН,
        'Телефон': get_random_phone()  # используй функцию для генерации телефона
    }

print(fake_builder('Дом у дороги'))
print(fake_builder('Шрут Дуайт Курт', org=False))

"""
Функции: практика

Задание 1


Напиши функцию mail_checker.
Она принимает на вход три параметра: mail_to — кому отправить, mail_from — от кого, mail_text — текст письма.
Функция ничего не возвращает, но печатает текст:
Получатель: {mail_to}
Отправитель: {mail_from}
Текст письма: {mail_text}
Вместо значений в {} поставь соответствующие значения входных параметров. 
Допиши код.

"""


# создай здесь функцию mail_checker
def mail_checker(mail_to, mail_from, mail_text):
    print('Получатель:', mail_to)
    print('Отправитель:', mail_from)
    print('Текст письма:', mail_text)


mail_checker(mail_to='john_connor@yandex.ru', mail_from='terminator@yandex.ru', mail_text='Привет, я вернулся!')

# должно получиться:
# Получатель: john_connor@yandex.ru
# Отправитель: terminator@yandex.ru
# Текст письма: Привет, я вернулся!

"""

Задание 2

Сделай так, чтобы функция сортировала письма по получателям.
Это должно работать так:
На вход функции подаются три параметра: mail_to, mail_from, mail_text.
Функция обрабатывает письмо и добавляет его в словарь mail_box.
Структура словаря следующая: 
mail_box = {
    'mail_to_A': [
        {'mail_from_B': 'mail_text_B_1'},
        {'mail_from_C': 'mail_text_C_1'},
                {'mail_from_B': 'mail_text_B_2'},
    ],
    'mail_to_B': [
        {'mail_from_D': 'mail_text_D_1'},
        {'mail_from_D': 'mail_text_D_2'}
    ]
} 
Ключи словаря — получатели mail_to.
Ключи уникальные.
Значением для ключа будет список, который состоит из словарей:
{'Отправитель': 'Текст письма'}.
Словарей в списке может быть много. На каждое письмо свой словарь.

"""
mail_box = {}

def mail_checker(mail_to, mail_from, mail_text):
    mail = {mail_from: mail_text}
    if mail_to in mail_box:
        mail_box[mail_to].append(mail)
    else:
        mail_box[mail_to] = [mail,]  # или mail_box[mail_to] = list(mail,)

# полученные письма
mail_checker(mail_to='john_connor@yandex.ru', mail_from='terminator@yandex.ru', mail_text='Привет, я вернулся!')

mail_checker(mail_to='john_connor@yandex.ru', mail_from='sarah_connor@yandex.ru', mail_text='Сынок, надень шапку')

mail_checker(mail_to='luke_skywalker@yandex.ru', mail_from='darth_vader@yandex.ru', mail_text='Правая рука чешется, не знаю, что и делать')

mail_checker(mail_to='luke_skywalker@yandex.ru', mail_from='darth_vader@yandex.ru', mail_text='Что бы сказал на это твой отец?')

print(mail_box)

"""
Задание 3

Теперь научи программу сортировать спам.
Письмо относится к спаму, если:
mail_text состоит только из заглавных букв;
текст содержит ссылку, которая начинается на https или www;
содержит одно из стоп-слов: 'Без вложений', 'Скидки', 'Распродажа', 'Выгода', 'Гарантия'.
{'Отправитель': 'Текст письма'} помещается в отдельный список spam и не добавляется в mail_box, если письмо — спам.
В остальных случаях письмо не относится к спаму и сортируется по тому же алгоритму, что был раньше. 
Письмо проверяется на спам функцией is_spam(mail_text).
Она возвращает True, если mail_text содержит спам, и False — если нет.
Функция проверки строки на наличие стоп-слова уже написана.

"""
mail_box = {}   # тут хранятся проверенные письма
spam = []   # сюда складываем спам

# проверка строки на наличие стоп-слов, используется внутри is_spam()
def str_contains_stop_words(string):
    stop_words = ['Без вложений', 'Скидки', 'Распродажа', 'Выгода', 'Гарантия']
    for w in stop_words:
        if w in string:
            return True
    return False

# проверка текста письма на спам, используется внутри mail_checker
def is_spam(mail_text):
    if mail_text == mail_text.upper() or 'https' in mail_text or str_contains_stop_words(mail_text):
        return True
    return False

def mail_checker(mail_to, mail_from, mail_text):
    mail = {mail_from: mail_text}
    if is_spam(mail_text):
        spam.append(mail)
        return
    if mail_to in mail_box:
        mail_box[mail_to].append(mail)
    else:
        mail_box[mail_to] = [mail,]  # или mail_box[mail_to] = list(mail,)

# полученные письма
mail_checker(mail_to='yoda_master@yandex.ru', mail_from='luke_skywalker@yandex.ru', mail_text='Магистр Йода, а в чём сила?')

mail_checker(mail_to='ilon_mask@yandex.ru', mail_from='trusted_mail@yandex.ru', mail_text='Скидки на акции Tesla, только у нас!')

mail_checker(mail_to='chandler_bing@yandex.ru', mail_from='ross_geller@yandex.ru', mail_text='Смотри, я открыл новый вид динозавра https://rossoceraptor.html')

mail_checker(mail_to='piter_parker@yandex.ru', mail_from='j_jonah_jameson@yandex.ru', mail_text='Паркер! Мне срочно нужны фото Паука!')

mail_checker(mail_to='neo@yandex.ru', mail_from='bad_matrix@yandex.ru', mail_text='РАСПРОДАЖА!!! ДВЕ КРАСНЫХ ТАБЛЕТКИ ПО ЦЕНЕ ТРЁХ СИНИХ')

print(mail_box)
# Будет выведено:
# '''
# {
#	'yoda_master@yandex.ru': [
#			{'luke_skywalker@yandex.ru': 'Магистр Йода, а в чем сила?'}
#	],
#	'piter_parker@yandex.ru': [
#			{'j_jonah_jameson@yandex.ru': 'Паркер! Мне срочно нужны фото Паука!'}
#	]
# }
# '''

print(spam)






